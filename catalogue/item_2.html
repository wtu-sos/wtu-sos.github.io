<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>条款2: 理解auto类型推导 | 个人主页</title>
    <meta name="description" content="Personal Website">
    <link rel="icon" href="favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.68be1f38.css" as="style"><link rel="preload" href="/assets/js/app.9bf7bf2a.js" as="script"><link rel="preload" href="/assets/js/7.e80d0feb.js" as="script"><link rel="prefetch" href="/assets/js/2.0f4038f2.js"><link rel="prefetch" href="/assets/js/3.b75823bc.js"><link rel="prefetch" href="/assets/js/4.e2e4d056.js"><link rel="prefetch" href="/assets/js/5.9d5719aa.js"><link rel="prefetch" href="/assets/js/6.ce4e8561.js"><link rel="prefetch" href="/assets/js/8.5d2f1411.js"><link rel="prefetch" href="/assets/js/9.4c178180.js">
    <link rel="stylesheet" href="/assets/css/0.styles.68be1f38.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">个人主页</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><!---->  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>Effective Modern C++</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/catalogue/chapter_1.html" class="sidebar-link">类型推导</a></li><li><a href="/catalogue/item_1.html" class="sidebar-link">条款1: 理解模板类型推导</a></li><li><a href="/catalogue/item_2.html" class="active sidebar-link">条款2: 理解auto类型推导</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="条款2-理解auto类型推导"><a href="#条款2-理解auto类型推导" aria-hidden="true" class="header-anchor">#</a> 条款2: 理解auto类型推导</h1> <p>如果你已经阅读了条款1中关于模板类型推导的内容,那么你已经知道了关于auto类型推导几乎所有的相关知识了,因为除了一些特例,auto类型推导其实就是模板类型推导.但这两者怎么会是相同的呢?模板类型推导包含了模板,函数和参数类型推导,但auto并不处理这些东西.</p> <p>这是对的,但并不是问题.模板类型推导与auto类型推导可以直接映射.字面上的意思就是有一个从一个到另一个的转换算法.</p> <p>在条款1中,模板类型推导用下面这个通用函数模板来解释:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>ParamType param<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这样来调用:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">f</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>以这样的方式调用函数f,编译器使用expr来推导T和ParamType的类型.
当一个变量通过auto来声明的时候,auto就扮演了模板中T的角色,对应变量的类型就是ParamType.相比描述来说,看一个例子更加直观:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这里,x的类型定义仅是auto自身.换个方式,这样声明的话:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">auto</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>x的类型是const auto.换成这样声明的话:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> rx<span class="token operator">=</span> x<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>x的类型是cosnt auto&amp;.编译器在推导上面的示例中x,cx,rx的类型时,就像这里有对应声明的一个模板,并且以对应的表达式来调用这些模板:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">&gt;</span>                  <span class="token comment">// 理论上等价于推导x的类型</span>
<span class="token keyword">void</span> <span class="token function">func_for_x</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">func_for_x</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 理论上调用中param的类型推导等价是于x的类型推导 </span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">&gt;</span>                  <span class="token comment">// 理论上等价于推导cx的类型</span>
<span class="token keyword">void</span> <span class="token function">func_for_x</span><span class="token punctuation">(</span><span class="token keyword">const</span> T param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">func_for_x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 同理</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">&gt;</span>                  <span class="token comment">// 理论上等价于推导rx的类型</span>
<span class="token keyword">void</span> <span class="token function">func_for_x</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">func_for_x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 同理</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>正如我所说的,auto推导类型与模板推导类型除了一个例外(我们即将讨论到),其它的都是相同的.
条款1在上面的通用函数模板中将模板类型推导根据ParamType和param的类型分成三个情况.在使用auto声明变量时,可以把类型说明符替换为ParamType,因此也可以将其分为三种情况:</p> <ul><li>情景 1: 类型说明符是指针或者引用,但不是一个通用引用.</li> <li>情景 2: 类型说明符是一个通用引用.</li> <li>情景 3: 类型说明符即不是指针也不是引用.</li></ul> <p>我们已经看过了情况1和3的示例代码:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>  <span class="token comment">// 情景3</span>

<span class="token keyword">const</span> <span class="token keyword">auto</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// 情景3</span>

<span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// 情景1: rx是一个非通用引用</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>情景2正如你预期的那样:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref1 <span class="token operator">=</span> x<span class="token punctuation">;</span>           <span class="token comment">//x是一个int左值</span>
                            <span class="token comment">// uref1的类型是int&amp;</span>

<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uerf2 <span class="token operator">=</span> cx<span class="token punctuation">;</span>          <span class="token comment">//x是一个int左值</span>
                            <span class="token comment">// uref2的类型是const int&amp;</span>

<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uerf3 <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>          <span class="token comment">//x是一个int右值</span>
                            <span class="token comment">// uref3的类型是int&amp;&amp;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>条款1总结了关于数组和函数类型这些非引用类型符号如何退化成指针的讨论.这些情况在auto类型推导中也有:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;R. N. Briggs&quot;</span><span class="token punctuation">;</span> <span class="token comment">// name的类型是const char[13]</span>

<span class="token keyword">auto</span> arr1 <span class="token operator">=</span> name<span class="token punctuation">;</span>                   <span class="token comment">// arr1的类型是const char*</span>

<span class="token keyword">auto</span><span class="token operator">&amp;</span> arr2 <span class="token operator">=</span> name<span class="token punctuation">;</span>                  <span class="token comment">// arr2的类型是 const char (&amp;)[13]</span>

<span class="token keyword">void</span> <span class="token function">someFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> func1 <span class="token operator">=</span> someFunc<span class="token punctuation">;</span>              <span class="token comment">// func1的类型是void (*)(int, double)</span>

<span class="token keyword">auto</span><span class="token operator">&amp;</span> func2 <span class="token operator">=</span> someFunc<span class="token punctuation">;</span>             <span class="token comment">// func1的类型是void (&amp;)(int, double)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>正如你所见的,auto类型推导与模板类型推导一样工作.它们是一体两面的.
只有一个方面是不同的.我们从假设要声明一个int型的变量并初始化为27,c++98提供两种语法选择:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> x1 <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">x2</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>c++11,支持了初始化列表,增加了这些方式:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> x3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> x4 <span class="token punctuation">{</span><span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>总而言之,四种语法,但产生了同一个结果:声明一个int类型变量初始化为27.
但正如条款5所阐述的,使用auto代码修饰类型来声明变量是有优势的,因此像下面这样使用auto来替换int来声明变量是一个好的选择.最直接的使用代码来描述就是这样的:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span> x1 <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token function">x2</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> x3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> x4 <span class="token punctuation">{</span><span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这些声明编译器全部可以编译通过,但它们一旦替换了就不再是同一种含义了.前两种声明方式确实是声明了一个值为27的int类型变量.
然后后续两个声明了一个包含一个值为27的元素的<code>std::innitializer_list&lt;int&gt;</code>类型的变量.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span> x1 <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>     <span class="token comment">// 类型是int,值为27</span>

<span class="token keyword">auto</span> <span class="token function">x2</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 同上</span>

<span class="token keyword">auto</span> x3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">// 类型是std::initializer_list&lt;int&gt;</span>
                  <span class="token comment">// 值为 { 27 }</span>

<span class="token keyword">auto</span> x4 <span class="token punctuation">{</span><span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment">// 同上</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这是由于auto的一个特殊的类型推导规则导致的.
当一个auto声明的变量初始值被花括号包裹时,
推导出来的类型就是<code>std::initializer_list</code>.如果这个类型无法被推导
(比如,由于初始化列表中的值类型是不一致),代码将无法通过编译:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span> x5 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 错误!无法推导出std::initializer_list&lt;T&gt;中T的类型</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>正如注释所描述的, 这种情况下类型推导将会失败, 但重要的是要意识到这里实际上是两种类型推导被取代了.
其一从auto的使用来看:x5的类型必需被推导出来.
因为x5的初始值是在大括号中,x5必需被推导成<code>std::initializer_list</code>.
但<code>std::initializer_list</code>是一个模板.
它的实例是针对某些类型T的<code>std::initializer_list&lt;T&gt;</code>,这意味着T的类型也必需被推导出来.
这里产生的类型推导属于第二种类型推导:模板函数推导的范围.
在这个例子中,因为初始化列表中不仅仅包含一个类型的值而推导失败.</p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/catalogue/item_1.html" class="prev">
          条款1: 理解模板类型推导
        </a></span> <!----></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.9bf7bf2a.js" defer></script><script src="/assets/js/7.e80d0feb.js" defer></script>
  </body>
</html>
